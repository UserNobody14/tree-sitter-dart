// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import '' as self;

/// Create a new parser.
@ffi.Native<ffi.Pointer<TSParser> Function()>()
external ffi.Pointer<TSParser> ts_parser_new();

/// Delete the parser, freeing all of the memory that it used.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSParser>)>()
external void ts_parser_delete(
  ffi.Pointer<TSParser> self,
);

/// Get the parser's current language.
@ffi.Native<ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSParser>)>()
external ffi.Pointer<TSLanguage> ts_parser_language(
  ffi.Pointer<TSParser> self,
);

/// Set the language that the parser should use for parsing.
///
/// Returns a boolean indicating whether or not the language was successfully
/// assigned. True means assignment succeeded. False means there was a version
/// mismatch: the language was generated with an incompatible version of the
/// Tree-sitter CLI. Check the language's ABI version using [`ts_language_abi_version`]
/// and compare it to this library's [`TREE_SITTER_LANGUAGE_VERSION`] and
/// [`TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION`] constants.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSParser>, ffi.Pointer<TSLanguage>)>()
external bool ts_parser_set_language(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<TSLanguage> language,
);

/// Set the ranges of text that the parser should include when parsing.
///
/// By default, the parser will always include entire documents. This function
/// allows you to parse only a *portion* of a document but still return a syntax
/// tree whose ranges match up with the document as a whole. You can also pass
/// multiple disjoint ranges.
///
/// The second and third parameters specify the location and length of an array
/// of ranges. The parser does *not* take ownership of these ranges; it copies
/// the data, so it doesn't matter how these ranges are allocated.
///
/// If `count` is zero, then the entire document will be parsed. Otherwise,
/// the given ranges must be ordered from earliest to latest in the document,
/// and they must not overlap. That is, the following must hold for all:
///
/// `i < count - 1`: `ranges[i].end_byte <= ranges[i + 1].start_byte`
///
/// If this requirement is not satisfied, the operation will fail, the ranges
/// will not be assigned, and this function will return `false`. On success,
/// this function returns `true`
@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TSParser>, ffi.Pointer<TSRange>, ffi.Uint32)>()
external bool ts_parser_set_included_ranges(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<TSRange> ranges,
  int count,
);

/// Get the ranges of text that the parser will include when parsing.
///
/// The returned pointer is owned by the parser. The caller should not free it
/// or write to it. The length of the array will be written to the given
/// `count` pointer.
@ffi.Native<
    ffi.Pointer<TSRange> Function(
        ffi.Pointer<TSParser>, ffi.Pointer<ffi.Uint32>)>()
external ffi.Pointer<TSRange> ts_parser_included_ranges(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<ffi.Uint32> count,
);

/// Use the parser to parse some source code and create a syntax tree.
///
/// If you are parsing this document for the first time, pass `NULL` for the
/// `old_tree` parameter. Otherwise, if you have already parsed an earlier
/// version of this document and the document has since been edited, pass the
/// previous syntax tree so that the unchanged parts of it can be reused.
/// This will save time and memory. For this to work correctly, you must have
/// already edited the old syntax tree using the [`ts_tree_edit`] function in a
/// way that exactly matches the source code changes.
///
/// The [`TSInput`] parameter lets you specify how to read the text. It has the
/// following three fields:
/// 1. [`read`]: A function to retrieve a chunk of text at a given byte offset
/// and (row, column) position. The function should return a pointer to the
/// text and write its length to the [`bytes_read`] pointer. The parser does
/// not take ownership of this buffer; it just borrows it until it has
/// finished reading it. The function should write a zero value to the
/// [`bytes_read`] pointer to indicate the end of the document.
/// 2. [`payload`]: An arbitrary pointer that will be passed to each invocation
/// of the [`read`] function.
/// 3. [`encoding`]: An indication of how the text is encoded. Either
/// `TSInputEncodingUTF8` or `TSInputEncodingUTF16`.
///
/// This function returns a syntax tree on success, and `NULL` on failure. There
/// are four possible reasons for failure:
/// 1. The parser does not have a language assigned. Check for this using the
/// [`ts_parser_language`] function.
/// 2. Parsing was cancelled due to a timeout that was set by an earlier call to
/// the [`ts_parser_set_timeout_micros`] function. You can resume parsing from
/// where the parser left out by calling [`ts_parser_parse`] again with the
/// same arguments. Or you can start parsing from scratch by first calling
/// [`ts_parser_reset`].
/// 3. Parsing was cancelled using a cancellation flag that was set by an
/// earlier call to [`ts_parser_set_cancellation_flag`]. You can resume parsing
/// from where the parser left out by calling [`ts_parser_parse`] again with
/// the same arguments.
/// 4. Parsing was cancelled due to the progress callback returning true. This callback
/// is passed in [`ts_parser_parse_with_options`] inside the [`TSParseOptions`] struct.
///
/// [`read`]: TSInput::read
/// [`payload`]: TSInput::payload
/// [`encoding`]: TSInput::encoding
/// [`bytes_read`]: TSInput::read
@ffi.Native<
    ffi.Pointer<TSTree> Function(
        ffi.Pointer<TSParser>, ffi.Pointer<TSTree>, TSInput)>()
external ffi.Pointer<TSTree> ts_parser_parse(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<TSTree> old_tree,
  TSInput input,
);

/// Use the parser to parse some source code and create a syntax tree, with some options.
///
/// See [`ts_parser_parse`] for more details.
///
/// See [`TSParseOptions`] for more details on the options.
@ffi.Native<
    ffi.Pointer<TSTree> Function(
        ffi.Pointer<TSParser>, ffi.Pointer<TSTree>, TSInput, TSParseOptions)>()
external ffi.Pointer<TSTree> ts_parser_parse_with_options(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<TSTree> old_tree,
  TSInput input,
  TSParseOptions parse_options,
);

/// Use the parser to parse some source code stored in one contiguous buffer.
/// The first two parameters are the same as in the [`ts_parser_parse`] function
/// above. The second two parameters indicate the location of the buffer and its
/// length in bytes.
@ffi.Native<
    ffi.Pointer<TSTree> Function(ffi.Pointer<TSParser>, ffi.Pointer<TSTree>,
        ffi.Pointer<ffi.Char>, ffi.Uint32)>()
external ffi.Pointer<TSTree> ts_parser_parse_string(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<TSTree> old_tree,
  ffi.Pointer<ffi.Char> string,
  int length,
);

/// Use the parser to parse some source code stored in one contiguous buffer with
/// a given encoding. The first four parameters work the same as in the
/// [`ts_parser_parse_string`] method above. The final parameter indicates whether
/// the text is encoded as UTF8 or UTF16.
@ffi.Native<
    ffi.Pointer<TSTree> Function(
        ffi.Pointer<TSParser>,
        ffi.Pointer<TSTree>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
        ffi.UnsignedInt)>(symbol: 'ts_parser_parse_string_encoding')
external ffi.Pointer<TSTree> _ts_parser_parse_string_encoding(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<TSTree> old_tree,
  ffi.Pointer<ffi.Char> string,
  int length,
  int encoding,
);

ffi.Pointer<TSTree> ts_parser_parse_string_encoding(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<TSTree> old_tree,
  ffi.Pointer<ffi.Char> string,
  int length,
  TSInputEncoding encoding,
) =>
    _ts_parser_parse_string_encoding(
      self,
      old_tree,
      string,
      length,
      encoding.value,
    );

/// Instruct the parser to start the next parse from the beginning.
///
/// If the parser previously failed because of a timeout or a cancellation, then
/// by default, it will resume where it left off on the next call to
/// [`ts_parser_parse`] or other parsing functions. If you don't want to resume,
/// and instead intend to use this parser to parse some other document, you must
/// call [`ts_parser_reset`] first.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSParser>)>()
external void ts_parser_reset(
  ffi.Pointer<TSParser> self,
);

/// @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
///
/// Set the maximum duration in microseconds that parsing should be allowed to
/// take before halting.
///
/// If parsing takes longer than this, it will halt early, returning NULL.
/// See [`ts_parser_parse`] for more information.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSParser>, ffi.Uint64)>()
external void ts_parser_set_timeout_micros(
  ffi.Pointer<TSParser> self,
  int timeout_micros,
);

/// @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
///
/// Get the duration in microseconds that parsing is allowed to take.
@ffi.Native<ffi.Uint64 Function(ffi.Pointer<TSParser>)>()
external int ts_parser_timeout_micros(
  ffi.Pointer<TSParser> self,
);

/// @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
///
/// Set the parser's current cancellation flag pointer.
///
/// If a non-null pointer is assigned, then the parser will periodically read
/// from this pointer during parsing. If it reads a non-zero value, it will
/// halt early, returning NULL. See [`ts_parser_parse`] for more information.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSParser>, ffi.Pointer<ffi.Size>)>()
external void ts_parser_set_cancellation_flag(
  ffi.Pointer<TSParser> self,
  ffi.Pointer<ffi.Size> flag,
);

/// @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
///
/// Get the parser's current cancellation flag pointer.
@ffi.Native<ffi.Pointer<ffi.Size> Function(ffi.Pointer<TSParser>)>()
external ffi.Pointer<ffi.Size> ts_parser_cancellation_flag(
  ffi.Pointer<TSParser> self,
);

/// Set the logger that a parser should use during parsing.
///
/// The parser does not take ownership over the logger payload. If a logger was
/// previously assigned, the caller is responsible for releasing any memory
/// owned by the previous logger.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSParser>, TSLogger)>()
external void ts_parser_set_logger(
  ffi.Pointer<TSParser> self,
  TSLogger logger,
);

/// Get the parser's current logger.
@ffi.Native<TSLogger Function(ffi.Pointer<TSParser>)>()
external TSLogger ts_parser_logger(
  ffi.Pointer<TSParser> self,
);

/// Set the file descriptor to which the parser should write debugging graphs
/// during parsing. The graphs are formatted in the DOT language. You may want
/// to pipe these graphs directly to a `dot(1)` process in order to generate
/// SVG output. You can turn off this logging by passing a negative number.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSParser>, ffi.Int)>()
external void ts_parser_print_dot_graphs(
  ffi.Pointer<TSParser> self,
  int fd,
);

/// Create a shallow copy of the syntax tree. This is very fast.
///
/// You need to copy a syntax tree in order to use it on more than one thread at
/// a time, as syntax trees are not thread safe.
@ffi.Native<ffi.Pointer<TSTree> Function(ffi.Pointer<TSTree>)>()
external ffi.Pointer<TSTree> ts_tree_copy(
  ffi.Pointer<TSTree> self,
);

/// Delete the syntax tree, freeing all of the memory that it used.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSTree>)>()
external void ts_tree_delete(
  ffi.Pointer<TSTree> self,
);

/// Get the root node of the syntax tree.
@ffi.Native<TSNode Function(ffi.Pointer<TSTree>)>()
external TSNode ts_tree_root_node(
  ffi.Pointer<TSTree> self,
);

/// Get the root node of the syntax tree, but with its position
/// shifted forward by the given offset.
@ffi.Native<TSNode Function(ffi.Pointer<TSTree>, ffi.Uint32, TSPoint)>()
external TSNode ts_tree_root_node_with_offset(
  ffi.Pointer<TSTree> self,
  int offset_bytes,
  TSPoint offset_extent,
);

/// Get the language that was used to parse the syntax tree.
@ffi.Native<ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSTree>)>()
external ffi.Pointer<TSLanguage> ts_tree_language(
  ffi.Pointer<TSTree> self,
);

/// Get the array of included ranges that was used to parse the syntax tree.
///
/// The returned pointer must be freed by the caller.
@ffi.Native<
    ffi.Pointer<TSRange> Function(
        ffi.Pointer<TSTree>, ffi.Pointer<ffi.Uint32>)>()
external ffi.Pointer<TSRange> ts_tree_included_ranges(
  ffi.Pointer<TSTree> self,
  ffi.Pointer<ffi.Uint32> length,
);

/// Edit the syntax tree to keep it in sync with source code that has been
/// edited.
///
/// You must describe the edit both in terms of byte offsets and in terms of
/// (row, column) coordinates.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSTree>, ffi.Pointer<TSInputEdit>)>()
external void ts_tree_edit(
  ffi.Pointer<TSTree> self,
  ffi.Pointer<TSInputEdit> edit,
);

/// Compare an old edited syntax tree to a new syntax tree representing the same
/// document, returning an array of ranges whose syntactic structure has changed.
///
/// For this to work correctly, the old syntax tree must have been edited such
/// that its ranges match up to the new tree. Generally, you'll want to call
/// this function right after calling one of the [`ts_parser_parse`] functions.
/// You need to pass the old tree that was passed to parse, as well as the new
/// tree that was returned from that function.
///
/// The returned ranges indicate areas where the hierarchical structure of syntax
/// nodes (from root to leaf) has changed between the old and new trees. Characters
/// outside these ranges have identical ancestor nodes in both trees.
///
/// Note that the returned ranges may be slightly larger than the exact changed areas,
/// but Tree-sitter attempts to make them as small as possible.
///
/// The returned array is allocated using `malloc` and the caller is responsible
/// for freeing it using `free`. The length of the array will be written to the
/// given `length` pointer.
@ffi.Native<
    ffi.Pointer<TSRange> Function(
        ffi.Pointer<TSTree>, ffi.Pointer<TSTree>, ffi.Pointer<ffi.Uint32>)>()
external ffi.Pointer<TSRange> ts_tree_get_changed_ranges(
  ffi.Pointer<TSTree> old_tree,
  ffi.Pointer<TSTree> new_tree,
  ffi.Pointer<ffi.Uint32> length,
);

/// Write a DOT graph describing the syntax tree to the given file.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSTree>, ffi.Int)>()
external void ts_tree_print_dot_graph(
  ffi.Pointer<TSTree> self,
  int file_descriptor,
);

/// Get the node's type as a null-terminated string.
@ffi.Native<ffi.Pointer<ffi.Char> Function(TSNode)>()
external ffi.Pointer<ffi.Char> ts_node_type(
  TSNode self,
);

/// Get the node's type as a numerical id.
@ffi.Native<TSSymbol Function(TSNode)>()
external int ts_node_symbol(
  TSNode self,
);

/// Get the node's language.
@ffi.Native<ffi.Pointer<TSLanguage> Function(TSNode)>()
external ffi.Pointer<TSLanguage> ts_node_language(
  TSNode self,
);

/// Get the node's type as it appears in the grammar ignoring aliases as a
/// null-terminated string.
@ffi.Native<ffi.Pointer<ffi.Char> Function(TSNode)>()
external ffi.Pointer<ffi.Char> ts_node_grammar_type(
  TSNode self,
);

/// Get the node's type as a numerical id as it appears in the grammar ignoring
/// aliases. This should be used in [`ts_language_next_state`] instead of
/// [`ts_node_symbol`].
@ffi.Native<TSSymbol Function(TSNode)>()
external int ts_node_grammar_symbol(
  TSNode self,
);

/// Get the node's start byte.
@ffi.Native<ffi.Uint32 Function(TSNode)>()
external int ts_node_start_byte(
  TSNode self,
);

/// Get the node's start position in terms of rows and columns.
@ffi.Native<TSPoint Function(TSNode)>()
external TSPoint ts_node_start_point(
  TSNode self,
);

/// Get the node's end byte.
@ffi.Native<ffi.Uint32 Function(TSNode)>()
external int ts_node_end_byte(
  TSNode self,
);

/// Get the node's end position in terms of rows and columns.
@ffi.Native<TSPoint Function(TSNode)>()
external TSPoint ts_node_end_point(
  TSNode self,
);

/// Get an S-expression representing the node as a string.
///
/// This string is allocated with `malloc` and the caller is responsible for
/// freeing it using `free`.
@ffi.Native<ffi.Pointer<ffi.Char> Function(TSNode)>()
external ffi.Pointer<ffi.Char> ts_node_string(
  TSNode self,
);

/// Check if the node is null. Functions like [`ts_node_child`] and
/// [`ts_node_next_sibling`] will return a null node to indicate that no such node
/// was found.
@ffi.Native<ffi.Bool Function(TSNode)>()
external bool ts_node_is_null(
  TSNode self,
);

/// Check if the node is *named*. Named nodes correspond to named rules in the
/// grammar, whereas *anonymous* nodes correspond to string literals in the
/// grammar.
@ffi.Native<ffi.Bool Function(TSNode)>()
external bool ts_node_is_named(
  TSNode self,
);

/// Check if the node is *missing*. Missing nodes are inserted by the parser in
/// order to recover from certain kinds of syntax errors.
@ffi.Native<ffi.Bool Function(TSNode)>()
external bool ts_node_is_missing(
  TSNode self,
);

/// Check if the node is *extra*. Extra nodes represent things like comments,
/// which are not required the grammar, but can appear anywhere.
@ffi.Native<ffi.Bool Function(TSNode)>()
external bool ts_node_is_extra(
  TSNode self,
);

/// Check if a syntax node has been edited.
@ffi.Native<ffi.Bool Function(TSNode)>()
external bool ts_node_has_changes(
  TSNode self,
);

/// Check if the node is a syntax error or contains any syntax errors.
@ffi.Native<ffi.Bool Function(TSNode)>()
external bool ts_node_has_error(
  TSNode self,
);

/// Check if the node is a syntax error.
@ffi.Native<ffi.Bool Function(TSNode)>()
external bool ts_node_is_error(
  TSNode self,
);

/// Get this node's parse state.
@ffi.Native<TSStateId Function(TSNode)>()
external int ts_node_parse_state(
  TSNode self,
);

/// Get the parse state after this node.
@ffi.Native<TSStateId Function(TSNode)>()
external int ts_node_next_parse_state(
  TSNode self,
);

/// Get the node's immediate parent.
/// Prefer [`ts_node_child_with_descendant`] for
/// iterating over the node's ancestors.
@ffi.Native<TSNode Function(TSNode)>()
external TSNode ts_node_parent(
  TSNode self,
);

/// Get the node that contains `descendant`.
///
/// Note that this can return `descendant` itself.
@ffi.Native<TSNode Function(TSNode, TSNode)>()
external TSNode ts_node_child_with_descendant(
  TSNode self,
  TSNode descendant,
);

/// Get the node's child at the given index, where zero represents the first
/// child.
@ffi.Native<TSNode Function(TSNode, ffi.Uint32)>()
external TSNode ts_node_child(
  TSNode self,
  int child_index,
);

/// Get the field name for node's child at the given index, where zero represents
/// the first child. Returns NULL, if no field is found.
@ffi.Native<ffi.Pointer<ffi.Char> Function(TSNode, ffi.Uint32)>()
external ffi.Pointer<ffi.Char> ts_node_field_name_for_child(
  TSNode self,
  int child_index,
);

/// Get the field name for node's named child at the given index, where zero
/// represents the first named child. Returns NULL, if no field is found.
@ffi.Native<ffi.Pointer<ffi.Char> Function(TSNode, ffi.Uint32)>()
external ffi.Pointer<ffi.Char> ts_node_field_name_for_named_child(
  TSNode self,
  int named_child_index,
);

/// Get the node's number of children.
@ffi.Native<ffi.Uint32 Function(TSNode)>()
external int ts_node_child_count(
  TSNode self,
);

/// Get the node's *named* child at the given index.
///
/// See also [`ts_node_is_named`].
@ffi.Native<TSNode Function(TSNode, ffi.Uint32)>()
external TSNode ts_node_named_child(
  TSNode self,
  int child_index,
);

/// Get the node's number of *named* children.
///
/// See also [`ts_node_is_named`].
@ffi.Native<ffi.Uint32 Function(TSNode)>()
external int ts_node_named_child_count(
  TSNode self,
);

/// Get the node's child with the given field name.
@ffi.Native<TSNode Function(TSNode, ffi.Pointer<ffi.Char>, ffi.Uint32)>()
external TSNode ts_node_child_by_field_name(
  TSNode self,
  ffi.Pointer<ffi.Char> name,
  int name_length,
);

/// Get the node's child with the given numerical field id.
///
/// You can convert a field name to an id using the
/// [`ts_language_field_id_for_name`] function.
@ffi.Native<TSNode Function(TSNode, TSFieldId)>()
external TSNode ts_node_child_by_field_id(
  TSNode self,
  int field_id,
);

/// Get the node's next / previous sibling.
@ffi.Native<TSNode Function(TSNode)>()
external TSNode ts_node_next_sibling(
  TSNode self,
);

@ffi.Native<TSNode Function(TSNode)>()
external TSNode ts_node_prev_sibling(
  TSNode self,
);

/// Get the node's next / previous *named* sibling.
@ffi.Native<TSNode Function(TSNode)>()
external TSNode ts_node_next_named_sibling(
  TSNode self,
);

@ffi.Native<TSNode Function(TSNode)>()
external TSNode ts_node_prev_named_sibling(
  TSNode self,
);

/// Get the node's first child that contains or starts after the given byte offset.
@ffi.Native<TSNode Function(TSNode, ffi.Uint32)>()
external TSNode ts_node_first_child_for_byte(
  TSNode self,
  int byte,
);

/// Get the node's first named child that contains or starts after the given byte offset.
@ffi.Native<TSNode Function(TSNode, ffi.Uint32)>()
external TSNode ts_node_first_named_child_for_byte(
  TSNode self,
  int byte,
);

/// Get the node's number of descendants, including one for the node itself.
@ffi.Native<ffi.Uint32 Function(TSNode)>()
external int ts_node_descendant_count(
  TSNode self,
);

/// Get the smallest node within this node that spans the given range of bytes
/// or (row, column) positions.
@ffi.Native<TSNode Function(TSNode, ffi.Uint32, ffi.Uint32)>()
external TSNode ts_node_descendant_for_byte_range(
  TSNode self,
  int start,
  int end,
);

@ffi.Native<TSNode Function(TSNode, TSPoint, TSPoint)>()
external TSNode ts_node_descendant_for_point_range(
  TSNode self,
  TSPoint start,
  TSPoint end,
);

/// Get the smallest named node within this node that spans the given range of
/// bytes or (row, column) positions.
@ffi.Native<TSNode Function(TSNode, ffi.Uint32, ffi.Uint32)>()
external TSNode ts_node_named_descendant_for_byte_range(
  TSNode self,
  int start,
  int end,
);

@ffi.Native<TSNode Function(TSNode, TSPoint, TSPoint)>()
external TSNode ts_node_named_descendant_for_point_range(
  TSNode self,
  TSPoint start,
  TSPoint end,
);

/// Edit the node to keep it in-sync with source code that has been edited.
///
/// This function is only rarely needed. When you edit a syntax tree with the
/// [`ts_tree_edit`] function, all of the nodes that you retrieve from the tree
/// afterward will already reflect the edit. You only need to use [`ts_node_edit`]
/// when you have a [`TSNode`] instance that you want to keep and continue to use
/// after an edit.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSNode>, ffi.Pointer<TSInputEdit>)>()
external void ts_node_edit(
  ffi.Pointer<TSNode> self,
  ffi.Pointer<TSInputEdit> edit,
);

/// Check if two nodes are identical.
@ffi.Native<ffi.Bool Function(TSNode, TSNode)>()
external bool ts_node_eq(
  TSNode self,
  TSNode other,
);

/// Create a new tree cursor starting from the given node.
///
/// A tree cursor allows you to walk a syntax tree more efficiently than is
/// possible using the [`TSNode`] functions. It is a mutable object that is always
/// on a certain syntax node, and can be moved imperatively to different nodes.
///
/// Note that the given node is considered the root of the cursor,
/// and the cursor cannot walk outside this node.
@ffi.Native<TSTreeCursor Function(TSNode)>()
external TSTreeCursor ts_tree_cursor_new(
  TSNode node,
);

/// Delete a tree cursor, freeing all of the memory that it used.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSTreeCursor>)>()
external void ts_tree_cursor_delete(
  ffi.Pointer<TSTreeCursor> self,
);

/// Re-initialize a tree cursor to start at the original node that the cursor was
/// constructed with.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSTreeCursor>, TSNode)>()
external void ts_tree_cursor_reset(
  ffi.Pointer<TSTreeCursor> self,
  TSNode node,
);

/// Re-initialize a tree cursor to the same position as another cursor.
///
/// Unlike [`ts_tree_cursor_reset`], this will not lose parent information and
/// allows reusing already created cursors.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSTreeCursor>, ffi.Pointer<TSTreeCursor>)>()
external void ts_tree_cursor_reset_to(
  ffi.Pointer<TSTreeCursor> dst,
  ffi.Pointer<TSTreeCursor> src,
);

/// Get the tree cursor's current node.
@ffi.Native<TSNode Function(ffi.Pointer<TSTreeCursor>)>()
external TSNode ts_tree_cursor_current_node(
  ffi.Pointer<TSTreeCursor> self,
);

/// Get the field name of the tree cursor's current node.
///
/// This returns `NULL` if the current node doesn't have a field.
/// See also [`ts_node_child_by_field_name`].
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSTreeCursor>)>()
external ffi.Pointer<ffi.Char> ts_tree_cursor_current_field_name(
  ffi.Pointer<TSTreeCursor> self,
);

/// Get the field id of the tree cursor's current node.
///
/// This returns zero if the current node doesn't have a field.
/// See also [`ts_node_child_by_field_id`], [`ts_language_field_id_for_name`].
@ffi.Native<TSFieldId Function(ffi.Pointer<TSTreeCursor>)>()
external int ts_tree_cursor_current_field_id(
  ffi.Pointer<TSTreeCursor> self,
);

/// Move the cursor to the parent of its current node.
///
/// This returns `true` if the cursor successfully moved, and returns `false`
/// if there was no parent node (the cursor was already on the root node).
///
/// Note that the node the cursor was constructed with is considered the root
/// of the cursor, and the cursor cannot walk outside this node.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>()
external bool ts_tree_cursor_goto_parent(
  ffi.Pointer<TSTreeCursor> self,
);

/// Move the cursor to the next sibling of its current node.
///
/// This returns `true` if the cursor successfully moved, and returns `false`
/// if there was no next sibling node.
///
/// Note that the node the cursor was constructed with is considered the root
/// of the cursor, and the cursor cannot walk outside this node.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>()
external bool ts_tree_cursor_goto_next_sibling(
  ffi.Pointer<TSTreeCursor> self,
);

/// Move the cursor to the previous sibling of its current node.
///
/// This returns `true` if the cursor successfully moved, and returns `false` if
/// there was no previous sibling node.
///
/// Note, that this function may be slower than
/// [`ts_tree_cursor_goto_next_sibling`] due to how node positions are stored. In
/// the worst case, this will need to iterate through all the children up to the
/// previous sibling node to recalculate its position. Also note that the node the cursor
/// was constructed with is considered the root of the cursor, and the cursor cannot
/// walk outside this node.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>()
external bool ts_tree_cursor_goto_previous_sibling(
  ffi.Pointer<TSTreeCursor> self,
);

/// Move the cursor to the first child of its current node.
///
/// This returns `true` if the cursor successfully moved, and returns `false`
/// if there were no children.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>()
external bool ts_tree_cursor_goto_first_child(
  ffi.Pointer<TSTreeCursor> self,
);

/// Move the cursor to the last child of its current node.
///
/// This returns `true` if the cursor successfully moved, and returns `false` if
/// there were no children.
///
/// Note that this function may be slower than [`ts_tree_cursor_goto_first_child`]
/// because it needs to iterate through all the children to compute the child's
/// position.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>()
external bool ts_tree_cursor_goto_last_child(
  ffi.Pointer<TSTreeCursor> self,
);

/// Move the cursor to the node that is the nth descendant of
/// the original node that the cursor was constructed with, where
/// zero represents the original node itself.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSTreeCursor>, ffi.Uint32)>()
external void ts_tree_cursor_goto_descendant(
  ffi.Pointer<TSTreeCursor> self,
  int goal_descendant_index,
);

/// Get the index of the cursor's current node out of all of the
/// descendants of the original node that the cursor was constructed with.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSTreeCursor>)>()
external int ts_tree_cursor_current_descendant_index(
  ffi.Pointer<TSTreeCursor> self,
);

/// Get the depth of the cursor's current node relative to the original
/// node that the cursor was constructed with.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSTreeCursor>)>()
external int ts_tree_cursor_current_depth(
  ffi.Pointer<TSTreeCursor> self,
);

/// Move the cursor to the first child of its current node that contains or starts after
/// the given byte offset or point.
///
/// This returns the index of the child node if one was found, and returns -1
/// if no such child was found.
@ffi.Native<ffi.Int64 Function(ffi.Pointer<TSTreeCursor>, ffi.Uint32)>()
external int ts_tree_cursor_goto_first_child_for_byte(
  ffi.Pointer<TSTreeCursor> self,
  int goal_byte,
);

@ffi.Native<ffi.Int64 Function(ffi.Pointer<TSTreeCursor>, TSPoint)>()
external int ts_tree_cursor_goto_first_child_for_point(
  ffi.Pointer<TSTreeCursor> self,
  TSPoint goal_point,
);

@ffi.Native<TSTreeCursor Function(ffi.Pointer<TSTreeCursor>)>()
external TSTreeCursor ts_tree_cursor_copy(
  ffi.Pointer<TSTreeCursor> cursor,
);

/// Create a new query from a string containing one or more S-expression
/// patterns. The query is associated with a particular language, and can
/// only be run on syntax nodes parsed with that language.
///
/// If all of the given patterns are valid, this returns a [`TSQuery`].
/// If a pattern is invalid, this returns `NULL`, and provides two pieces
/// of information about the problem:
/// 1. The byte offset of the error is written to the `error_offset` parameter.
/// 2. The type of error is written to the `error_type` parameter.
@ffi.Native<
    ffi.Pointer<TSQuery> Function(
        ffi.Pointer<TSLanguage>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint32>,
        ffi.Pointer<ffi.UnsignedInt>)>()
external ffi.Pointer<TSQuery> ts_query_new(
  ffi.Pointer<TSLanguage> language,
  ffi.Pointer<ffi.Char> source,
  int source_len,
  ffi.Pointer<ffi.Uint32> error_offset,
  ffi.Pointer<ffi.UnsignedInt> error_type,
);

/// Delete a query, freeing all of the memory that it used.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSQuery>)>()
external void ts_query_delete(
  ffi.Pointer<TSQuery> self,
);

/// Get the number of patterns, captures, or string literals in the query.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSQuery>)>()
external int ts_query_pattern_count(
  ffi.Pointer<TSQuery> self,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSQuery>)>()
external int ts_query_capture_count(
  ffi.Pointer<TSQuery> self,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSQuery>)>()
external int ts_query_string_count(
  ffi.Pointer<TSQuery> self,
);

/// Get the byte offset where the given pattern starts in the query's source.
///
/// This can be useful when combining queries by concatenating their source
/// code strings.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSQuery>, ffi.Uint32)>()
external int ts_query_start_byte_for_pattern(
  ffi.Pointer<TSQuery> self,
  int pattern_index,
);

/// Get the byte offset where the given pattern ends in the query's source.
///
/// This can be useful when combining queries by concatenating their source
/// code strings.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSQuery>, ffi.Uint32)>()
external int ts_query_end_byte_for_pattern(
  ffi.Pointer<TSQuery> self,
  int pattern_index,
);

/// Get all of the predicates for the given pattern in the query.
///
/// The predicates are represented as a single array of steps. There are three
/// types of steps in this array, which correspond to the three legal values for
/// the `type` field:
/// - `TSQueryPredicateStepTypeCapture` - Steps with this type represent names
/// of captures. Their `value_id` can be used with the
/// [`ts_query_capture_name_for_id`] function to obtain the name of the capture.
/// - `TSQueryPredicateStepTypeString` - Steps with this type represent literal
/// strings. Their `value_id` can be used with the
/// [`ts_query_string_value_for_id`] function to obtain their string value.
/// - `TSQueryPredicateStepTypeDone` - Steps with this type are *sentinels*
/// that represent the end of an individual predicate. If a pattern has two
/// predicates, then there will be two steps with this `type` in the array.
@ffi.Native<
    ffi.Pointer<TSQueryPredicateStep> Function(
        ffi.Pointer<TSQuery>, ffi.Uint32, ffi.Pointer<ffi.Uint32>)>()
external ffi.Pointer<TSQueryPredicateStep> ts_query_predicates_for_pattern(
  ffi.Pointer<TSQuery> self,
  int pattern_index,
  ffi.Pointer<ffi.Uint32> step_count,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TSQuery>, ffi.Uint32)>()
external bool ts_query_is_pattern_rooted(
  ffi.Pointer<TSQuery> self,
  int pattern_index,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TSQuery>, ffi.Uint32)>()
external bool ts_query_is_pattern_non_local(
  ffi.Pointer<TSQuery> self,
  int pattern_index,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TSQuery>, ffi.Uint32)>()
external bool ts_query_is_pattern_guaranteed_at_step(
  ffi.Pointer<TSQuery> self,
  int byte_offset,
);

/// Get the name and length of one of the query's captures, or one of the
/// query's string literals. Each capture and string is associated with a
/// numeric id based on the order that it appeared in the query's source.
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TSQuery>, ffi.Uint32, ffi.Pointer<ffi.Uint32>)>()
external ffi.Pointer<ffi.Char> ts_query_capture_name_for_id(
  ffi.Pointer<TSQuery> self,
  int index,
  ffi.Pointer<ffi.Uint32> length,
);

/// Get the quantifier of the query's captures. Each capture is * associated
/// with a numeric id based on the order that it appeared in the query's source.
@ffi.Native<
        ffi.UnsignedInt Function(ffi.Pointer<TSQuery>, ffi.Uint32, ffi.Uint32)>(
    symbol: 'ts_query_capture_quantifier_for_id')
external int _ts_query_capture_quantifier_for_id(
  ffi.Pointer<TSQuery> self,
  int pattern_index,
  int capture_index,
);

TSQuantifier ts_query_capture_quantifier_for_id(
  ffi.Pointer<TSQuery> self,
  int pattern_index,
  int capture_index,
) =>
    TSQuantifier.fromValue(_ts_query_capture_quantifier_for_id(
      self,
      pattern_index,
      capture_index,
    ));

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TSQuery>, ffi.Uint32, ffi.Pointer<ffi.Uint32>)>()
external ffi.Pointer<ffi.Char> ts_query_string_value_for_id(
  ffi.Pointer<TSQuery> self,
  int index,
  ffi.Pointer<ffi.Uint32> length,
);

/// Disable a certain capture within a query.
///
/// This prevents the capture from being returned in matches, and also avoids
/// any resource usage associated with recording the capture. Currently, there
/// is no way to undo this.
@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSQuery>, ffi.Pointer<ffi.Char>, ffi.Uint32)>()
external void ts_query_disable_capture(
  ffi.Pointer<TSQuery> self,
  ffi.Pointer<ffi.Char> name,
  int length,
);

/// Disable a certain pattern within a query.
///
/// This prevents the pattern from matching and removes most of the overhead
/// associated with the pattern. Currently, there is no way to undo this.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSQuery>, ffi.Uint32)>()
external void ts_query_disable_pattern(
  ffi.Pointer<TSQuery> self,
  int pattern_index,
);

/// Create a new cursor for executing a given query.
///
/// The cursor stores the state that is needed to iteratively search
/// for matches. To use the query cursor, first call [`ts_query_cursor_exec`]
/// to start running a given query on a given syntax node. Then, there are
/// two options for consuming the results of the query:
/// 1. Repeatedly call [`ts_query_cursor_next_match`] to iterate over all of the
/// *matches* in the order that they were found. Each match contains the
/// index of the pattern that matched, and an array of captures. Because
/// multiple patterns can match the same set of nodes, one match may contain
/// captures that appear *before* some of the captures from a previous match.
/// 2. Repeatedly call [`ts_query_cursor_next_capture`] to iterate over all of the
/// individual *captures* in the order that they appear. This is useful if
/// don't care about which pattern matched, and just want a single ordered
/// sequence of captures.
///
/// If you don't care about consuming all of the results, you can stop calling
/// [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] at any point.
/// You can then start executing another query on another node by calling
/// [`ts_query_cursor_exec`] again.
@ffi.Native<ffi.Pointer<TSQueryCursor> Function()>()
external ffi.Pointer<TSQueryCursor> ts_query_cursor_new();

/// Delete a query cursor, freeing all of the memory that it used.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSQueryCursor>)>()
external void ts_query_cursor_delete(
  ffi.Pointer<TSQueryCursor> self,
);

/// Start running a given query on a given node.
@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSQueryCursor>, ffi.Pointer<TSQuery>, TSNode)>()
external void ts_query_cursor_exec(
  ffi.Pointer<TSQueryCursor> self,
  ffi.Pointer<TSQuery> query,
  TSNode node,
);

/// Start running a given query on a given node, with some options.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Pointer<TSQuery>, TSNode,
        ffi.Pointer<TSQueryCursorOptions>)>()
external void ts_query_cursor_exec_with_options(
  ffi.Pointer<TSQueryCursor> self,
  ffi.Pointer<TSQuery> query,
  TSNode node,
  ffi.Pointer<TSQueryCursorOptions> query_options,
);

/// Manage the maximum number of in-progress matches allowed by this query
/// cursor.
///
/// Query cursors have an optional maximum capacity for storing lists of
/// in-progress captures. If this capacity is exceeded, then the
/// earliest-starting match will silently be dropped to make room for further
/// matches. This maximum capacity is optional â€” by default, query cursors allow
/// any number of pending matches, dynamically allocating new space for them as
/// needed as the query is executed.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSQueryCursor>)>()
external bool ts_query_cursor_did_exceed_match_limit(
  ffi.Pointer<TSQueryCursor> self,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSQueryCursor>)>()
external int ts_query_cursor_match_limit(
  ffi.Pointer<TSQueryCursor> self,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Uint32)>()
external void ts_query_cursor_set_match_limit(
  ffi.Pointer<TSQueryCursor> self,
  int limit,
);

/// @deprecated use [`ts_query_cursor_exec_with_options`] and pass in a callback instead, this will be removed in 0.26.
///
/// Set the maximum duration in microseconds that query execution should be allowed to
/// take before halting.
///
/// If query execution takes longer than this, it will halt early, returning NULL.
/// See [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] for more information.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Uint64)>()
external void ts_query_cursor_set_timeout_micros(
  ffi.Pointer<TSQueryCursor> self,
  int timeout_micros,
);

/// @deprecated use [`ts_query_cursor_exec_with_options`] and pass in a callback instead, this will be removed in 0.26.
///
/// Get the duration in microseconds that query execution is allowed to take.
///
/// This is set via [`ts_query_cursor_set_timeout_micros`].
@ffi.Native<ffi.Uint64 Function(ffi.Pointer<TSQueryCursor>)>()
external int ts_query_cursor_timeout_micros(
  ffi.Pointer<TSQueryCursor> self,
);

/// Set the range of bytes in which the query will be executed.
///
/// The query cursor will return matches that intersect with the given point range.
/// This means that a match may be returned even if some of its captures fall
/// outside the specified range, as long as at least part of the match
/// overlaps with the range.
///
/// For example, if a query pattern matches a node that spans a larger area
/// than the specified range, but part of that node intersects with the range,
/// the entire match will be returned.
///
/// This will return `false` if the start byte is greater than the end byte, otherwise
/// it will return `true`.
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSQueryCursor>, ffi.Uint32, ffi.Uint32)>()
external bool ts_query_cursor_set_byte_range(
  ffi.Pointer<TSQueryCursor> self,
  int start_byte,
  int end_byte,
);

/// Set the range of (row, column) positions in which the query will be executed.
///
/// The query cursor will return matches that intersect with the given point range.
/// This means that a match may be returned even if some of its captures fall
/// outside the specified range, as long as at least part of the match
/// overlaps with the range.
///
/// For example, if a query pattern matches a node that spans a larger area
/// than the specified range, but part of that node intersects with the range,
/// the entire match will be returned.
///
/// This will return `false` if the start point is greater than the end point, otherwise
/// it will return `true`.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSQueryCursor>, TSPoint, TSPoint)>()
external bool ts_query_cursor_set_point_range(
  ffi.Pointer<TSQueryCursor> self,
  TSPoint start_point,
  TSPoint end_point,
);

/// Advance to the next match of the currently running query.
///
/// If there is a match, write it to `*match` and return `true`.
/// Otherwise, return `false`.
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSQueryCursor>, ffi.Pointer<TSQueryMatch>)>()
external bool ts_query_cursor_next_match(
  ffi.Pointer<TSQueryCursor> self,
  ffi.Pointer<TSQueryMatch> match,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Uint32)>()
external void ts_query_cursor_remove_match(
  ffi.Pointer<TSQueryCursor> self,
  int match_id,
);

/// Advance to the next capture of the currently running query.
///
/// If there is a capture, write its match to `*match` and its index within
/// the match's capture list to `*capture_index`. Otherwise, return `false`.
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSQueryCursor>, ffi.Pointer<TSQueryMatch>,
        ffi.Pointer<ffi.Uint32>)>()
external bool ts_query_cursor_next_capture(
  ffi.Pointer<TSQueryCursor> self,
  ffi.Pointer<TSQueryMatch> match,
  ffi.Pointer<ffi.Uint32> capture_index,
);

/// Set the maximum start depth for a query cursor.
///
/// This prevents cursors from exploring children nodes at a certain depth.
/// Note if a pattern includes many children, then they will still be checked.
///
/// The zero max start depth value can be used as a special behavior and
/// it helps to destructure a subtree by staying on a node and using captures
/// for interested parts. Note that the zero max start depth only limit a search
/// depth for a pattern's root node but other nodes that are parts of the pattern
/// may be searched at any depth what defined by the pattern structure.
///
/// Set to `UINT32_MAX` to remove the maximum start depth.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Uint32)>()
external void ts_query_cursor_set_max_start_depth(
  ffi.Pointer<TSQueryCursor> self,
  int max_start_depth,
);

/// Get another reference to the given language.
@ffi.Native<ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSLanguage>)>()
external ffi.Pointer<TSLanguage> ts_language_copy(
  ffi.Pointer<TSLanguage> self,
);

/// Free any dynamically-allocated resources for this language, if
/// this is the last reference.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSLanguage>)>()
external void ts_language_delete(
  ffi.Pointer<TSLanguage> self,
);

/// Get the number of distinct node types in the language.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>()
external int ts_language_symbol_count(
  ffi.Pointer<TSLanguage> self,
);

/// Get the number of valid states in this language.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>()
external int ts_language_state_count(
  ffi.Pointer<TSLanguage> self,
);

/// Get the numerical id for the given node type string.
@ffi.Native<
    TSSymbol Function(
        ffi.Pointer<TSLanguage>, ffi.Pointer<ffi.Char>, ffi.Uint32, ffi.Bool)>()
external int ts_language_symbol_for_name(
  ffi.Pointer<TSLanguage> self,
  ffi.Pointer<ffi.Char> string,
  int length,
  bool is_named,
);

/// Get the number of distinct field names in the language.
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>()
external int ts_language_field_count(
  ffi.Pointer<TSLanguage> self,
);

/// Get the field name string for the given numerical id.
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>, TSFieldId)>()
external ffi.Pointer<ffi.Char> ts_language_field_name_for_id(
  ffi.Pointer<TSLanguage> self,
  int id,
);

/// Get the numerical id for the given field name string.
@ffi.Native<
    TSFieldId Function(
        ffi.Pointer<TSLanguage>, ffi.Pointer<ffi.Char>, ffi.Uint32)>()
external int ts_language_field_id_for_name(
  ffi.Pointer<TSLanguage> self,
  ffi.Pointer<ffi.Char> name,
  int name_length,
);

/// Get a list of all supertype symbols for the language.
@ffi.Native<
    ffi.Pointer<TSSymbol> Function(
        ffi.Pointer<TSLanguage>, ffi.Pointer<ffi.Uint32>)>()
external ffi.Pointer<TSSymbol> ts_language_supertypes(
  ffi.Pointer<TSLanguage> self,
  ffi.Pointer<ffi.Uint32> length,
);

/// Get a list of all subtype symbol ids for a given supertype symbol.
///
/// See [`ts_language_supertypes`] for fetching all supertype symbols.
@ffi.Native<
    ffi.Pointer<TSSymbol> Function(
        ffi.Pointer<TSLanguage>, TSSymbol, ffi.Pointer<ffi.Uint32>)>()
external ffi.Pointer<TSSymbol> ts_language_subtypes(
  ffi.Pointer<TSLanguage> self,
  int supertype,
  ffi.Pointer<ffi.Uint32> length,
);

/// Get a node type string for the given numerical id.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>, TSSymbol)>()
external ffi.Pointer<ffi.Char> ts_language_symbol_name(
  ffi.Pointer<TSLanguage> self,
  int symbol,
);

/// Check whether the given node type id belongs to named nodes, anonymous nodes,
/// or a hidden nodes.
///
/// See also [`ts_node_is_named`]. Hidden nodes are never returned from the API.
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<TSLanguage>, TSSymbol)>(
    symbol: 'ts_language_symbol_type')
external int _ts_language_symbol_type(
  ffi.Pointer<TSLanguage> self,
  int symbol,
);

TSSymbolType ts_language_symbol_type(
  ffi.Pointer<TSLanguage> self,
  DartTSSymbol symbol,
) =>
    TSSymbolType.fromValue(_ts_language_symbol_type(
      self,
      symbol,
    ));

/// @deprecated use [`ts_language_abi_version`] instead, this will be removed in 0.26.
///
/// Get the ABI version number for this language. This version number is used
/// to ensure that languages were generated by a compatible version of
/// Tree-sitter.
///
/// See also [`ts_parser_set_language`].
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>()
external int ts_language_version(
  ffi.Pointer<TSLanguage> self,
);

/// Get the ABI version number for this language. This version number is used
/// to ensure that languages were generated by a compatible version of
/// Tree-sitter.
///
/// See also [`ts_parser_set_language`].
@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>()
external int ts_language_abi_version(
  ffi.Pointer<TSLanguage> self,
);

/// Get the metadata for this language. This information is generated by the
/// CLI, and relies on the language author providing the correct metadata in
/// the language's `tree-sitter.json` file.
///
/// See also [`TSMetadata`].
@ffi.Native<ffi.Pointer<TSLanguageMetadata> Function(ffi.Pointer<TSLanguage>)>()
external ffi.Pointer<TSLanguageMetadata> ts_language_metadata(
  ffi.Pointer<TSLanguage> self,
);

/// Get the next parse state. Combine this with lookahead iterators to generate
/// completion suggestions or valid symbols in error nodes. Use
/// [`ts_node_grammar_symbol`] for valid symbols.
@ffi.Native<TSStateId Function(ffi.Pointer<TSLanguage>, TSStateId, TSSymbol)>()
external int ts_language_next_state(
  ffi.Pointer<TSLanguage> self,
  int state,
  int symbol,
);

/// Get the name of this language. This returns `NULL` in older parsers.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>)>()
external ffi.Pointer<ffi.Char> ts_language_name(
  ffi.Pointer<TSLanguage> self,
);

/// Create a new lookahead iterator for the given language and parse state.
///
/// This returns `NULL` if state is invalid for the language.
///
/// Repeatedly using [`ts_lookahead_iterator_next`] and
/// [`ts_lookahead_iterator_current_symbol`] will generate valid symbols in the
/// given parse state. Newly created lookahead iterators will contain the `ERROR`
/// symbol.
///
/// Lookahead iterators can be useful to generate suggestions and improve syntax
/// error diagnostics. To get symbols valid in an ERROR node, use the lookahead
/// iterator on its first leaf node state. For `MISSING` nodes, a lookahead
/// iterator created on the previous non-extra leaf node may be appropriate.
@ffi.Native<
    ffi.Pointer<TSLookaheadIterator> Function(
        ffi.Pointer<TSLanguage>, TSStateId)>()
external ffi.Pointer<TSLookaheadIterator> ts_lookahead_iterator_new(
  ffi.Pointer<TSLanguage> self,
  int state,
);

/// Delete a lookahead iterator freeing all the memory used.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSLookaheadIterator>)>()
external void ts_lookahead_iterator_delete(
  ffi.Pointer<TSLookaheadIterator> self,
);

/// Reset the lookahead iterator to another state.
///
/// This returns `true` if the iterator was reset to the given state and `false`
/// otherwise.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSLookaheadIterator>, TSStateId)>()
external bool ts_lookahead_iterator_reset_state(
  ffi.Pointer<TSLookaheadIterator> self,
  int state,
);

/// Reset the lookahead iterator.
///
/// This returns `true` if the language was set successfully and `false`
/// otherwise.
@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TSLookaheadIterator>, ffi.Pointer<TSLanguage>, TSStateId)>()
external bool ts_lookahead_iterator_reset(
  ffi.Pointer<TSLookaheadIterator> self,
  ffi.Pointer<TSLanguage> language,
  int state,
);

/// Get the current language of the lookahead iterator.
@ffi.Native<
    ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSLookaheadIterator>)>()
external ffi.Pointer<TSLanguage> ts_lookahead_iterator_language(
  ffi.Pointer<TSLookaheadIterator> self,
);

/// Advance the lookahead iterator to the next symbol.
///
/// This returns `true` if there is a new symbol and `false` otherwise.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSLookaheadIterator>)>()
external bool ts_lookahead_iterator_next(
  ffi.Pointer<TSLookaheadIterator> self,
);

/// Get the current symbol of the lookahead iterator;
@ffi.Native<TSSymbol Function(ffi.Pointer<TSLookaheadIterator>)>()
external int ts_lookahead_iterator_current_symbol(
  ffi.Pointer<TSLookaheadIterator> self,
);

/// Get the current symbol type of the lookahead iterator as a null terminated
/// string.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLookaheadIterator>)>()
external ffi.Pointer<ffi.Char> ts_lookahead_iterator_current_symbol_name(
  ffi.Pointer<TSLookaheadIterator> self,
);

/// Create a Wasm store.
@ffi.Native<
    ffi.Pointer<TSWasmStore> Function(
        ffi.Pointer<TSWasmEngine>, ffi.Pointer<TSWasmError>)>()
external ffi.Pointer<TSWasmStore> ts_wasm_store_new(
  ffi.Pointer<TSWasmEngine> engine,
  ffi.Pointer<TSWasmError> error,
);

/// Free the memory associated with the given Wasm store.
@ffi.Native<ffi.Void Function(ffi.Pointer<TSWasmStore>)>()
external void ts_wasm_store_delete(
  ffi.Pointer<TSWasmStore> arg0,
);

/// Create a language from a buffer of Wasm. The resulting language behaves
/// like any other Tree-sitter language, except that in order to use it with
/// a parser, that parser must have a Wasm store. Note that the language
/// can be used with any Wasm store, it doesn't need to be the same store that
/// was used to originally load it.
@ffi.Native<
    ffi.Pointer<TSLanguage> Function(
        ffi.Pointer<TSWasmStore>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
        ffi.Pointer<TSWasmError>)>()
external ffi.Pointer<TSLanguage> ts_wasm_store_load_language(
  ffi.Pointer<TSWasmStore> arg0,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Char> wasm,
  int wasm_len,
  ffi.Pointer<TSWasmError> error,
);

/// Get the number of languages instantiated in the given wasm store.
@ffi.Native<ffi.Size Function(ffi.Pointer<TSWasmStore>)>()
external int ts_wasm_store_language_count(
  ffi.Pointer<TSWasmStore> arg0,
);

/// Check if the language came from a Wasm module. If so, then in order to use
/// this language with a Parser, that parser must have a Wasm store assigned.
@ffi.Native<ffi.Bool Function(ffi.Pointer<TSLanguage>)>()
external bool ts_language_is_wasm(
  ffi.Pointer<TSLanguage> arg0,
);

/// Assign the given Wasm store to the parser. A parser must have a Wasm store
/// in order to use Wasm languages.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSParser>, ffi.Pointer<TSWasmStore>)>()
external void ts_parser_set_wasm_store(
  ffi.Pointer<TSParser> arg0,
  ffi.Pointer<TSWasmStore> arg1,
);

/// Remove the parser's current Wasm store and return it. This returns NULL if
/// the parser doesn't have a Wasm store.
@ffi.Native<ffi.Pointer<TSWasmStore> Function(ffi.Pointer<TSParser>)>()
external ffi.Pointer<TSWasmStore> ts_parser_take_wasm_store(
  ffi.Pointer<TSParser> arg0,
);

/// Set the allocation functions used by the library.
///
/// By default, Tree-sitter uses the standard libc allocation functions,
/// but aborts the process when an allocation fails. This function lets
/// you supply alternative allocation functions at runtime.
///
/// If you pass `NULL` for any parameter, Tree-sitter will switch back to
/// its default implementation of that function.
///
/// If you call this function after the library has already been used, then
/// you must ensure that either:
/// 1. All the existing objects have been freed.
/// 2. The new allocator shares its state with the old one, so it is capable
/// of freeing memory that was allocated by the old allocator.
@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<
            ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Pointer<ffi.Void> Function(
                    ffi.Pointer<ffi.Void>, ffi.Size)>>,
        ffi.Pointer<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>()
external void ts_set_allocator(
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>
      new_malloc,
  ffi.Pointer<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>
      new_calloc,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)>>
      new_realloc,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      new_free,
);

const addresses = _SymbolAddresses();

class _SymbolAddresses {
  const _SymbolAddresses();
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSParser>)>>
      get ts_parser_delete => ffi.Native.addressOf(self.ts_parser_delete);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSTree>)>>
      get ts_tree_delete => ffi.Native.addressOf(self.ts_tree_delete);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSTreeCursor>)>>
      get ts_tree_cursor_delete =>
          ffi.Native.addressOf(self.ts_tree_cursor_delete);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSQuery>)>>
      get ts_query_delete => ffi.Native.addressOf(self.ts_query_delete);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSQueryCursor>)>>
      get ts_query_cursor_delete =>
          ffi.Native.addressOf(self.ts_query_cursor_delete);
}

/// /
typedef TSStateId = ffi.Uint16;
typedef DartTSStateId = int;
typedef TSSymbol = ffi.Uint16;
typedef DartTSSymbol = int;
typedef TSFieldId = ffi.Uint16;
typedef DartTSFieldId = int;

final class TSLanguage extends ffi.Opaque {}

final class TSParser extends ffi.Opaque {}

final class TSTree extends ffi.Opaque {}

final class TSQuery extends ffi.Opaque {}

final class TSQueryCursor extends ffi.Opaque {}

final class TSLookaheadIterator extends ffi.Opaque {}

typedef DecodeFunctionFunction = ffi.Uint32 Function(
    ffi.Pointer<ffi.Uint8> string,
    ffi.Uint32 length,
    ffi.Pointer<ffi.Int32> code_point);
typedef DartDecodeFunctionFunction = int Function(ffi.Pointer<ffi.Uint8> string,
    int length, ffi.Pointer<ffi.Int32> code_point);
typedef DecodeFunction
    = ffi.Pointer<ffi.NativeFunction<DecodeFunctionFunction>>;

enum TSInputEncoding {
  TSInputEncodingUTF8(0),
  TSInputEncodingUTF16LE(1),
  TSInputEncodingUTF16BE(2),
  TSInputEncodingCustom(3);

  final int value;
  const TSInputEncoding(this.value);

  static TSInputEncoding fromValue(int value) => switch (value) {
        0 => TSInputEncodingUTF8,
        1 => TSInputEncodingUTF16LE,
        2 => TSInputEncodingUTF16BE,
        3 => TSInputEncodingCustom,
        _ => throw ArgumentError('Unknown value for TSInputEncoding: $value'),
      };
}

enum TSSymbolType {
  TSSymbolTypeRegular(0),
  TSSymbolTypeAnonymous(1),
  TSSymbolTypeSupertype(2),
  TSSymbolTypeAuxiliary(3);

  final int value;
  const TSSymbolType(this.value);

  static TSSymbolType fromValue(int value) => switch (value) {
        0 => TSSymbolTypeRegular,
        1 => TSSymbolTypeAnonymous,
        2 => TSSymbolTypeSupertype,
        3 => TSSymbolTypeAuxiliary,
        _ => throw ArgumentError('Unknown value for TSSymbolType: $value'),
      };
}

final class TSPoint extends ffi.Struct {
  @ffi.Uint32()
  external int row;

  @ffi.Uint32()
  external int column;
}

final class TSRange extends ffi.Struct {
  external TSPoint start_point;

  external TSPoint end_point;

  @ffi.Uint32()
  external int start_byte;

  @ffi.Uint32()
  external int end_byte;
}

final class TSInput extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Void> payload,
              ffi.Uint32 byte_index,
              TSPoint position,
              ffi.Pointer<ffi.Uint32> bytes_read)>> read;

  @ffi.UnsignedInt()
  external int encodingAsInt;

  TSInputEncoding get encoding => TSInputEncoding.fromValue(encodingAsInt);

  external DecodeFunction decode;
}

final class TSParseState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  @ffi.Uint32()
  external int current_byte_offset;

  @ffi.Bool()
  external bool has_error;
}

final class TSParseOptions extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<TSParseState> state)>>
      progress_callback;
}

enum TSLogType {
  TSLogTypeParse(0),
  TSLogTypeLex(1);

  final int value;
  const TSLogType(this.value);

  static TSLogType fromValue(int value) => switch (value) {
        0 => TSLogTypeParse,
        1 => TSLogTypeLex,
        _ => throw ArgumentError('Unknown value for TSLogType: $value'),
      };
}

final class TSLogger extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> payload,
              ffi.UnsignedInt log_type, ffi.Pointer<ffi.Char> buffer)>> log;
}

final class TSInputEdit extends ffi.Struct {
  @ffi.Uint32()
  external int start_byte;

  @ffi.Uint32()
  external int old_end_byte;

  @ffi.Uint32()
  external int new_end_byte;

  external TSPoint start_point;

  external TSPoint old_end_point;

  external TSPoint new_end_point;
}

final class TSNode extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> context;

  external ffi.Pointer<ffi.Void> id;

  external ffi.Pointer<TSTree> tree;
}

final class TSTreeCursor extends ffi.Struct {
  external ffi.Pointer<ffi.Void> tree;

  external ffi.Pointer<ffi.Void> id;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> context;
}

final class TSQueryCapture extends ffi.Struct {
  external TSNode node;

  @ffi.Uint32()
  external int index;
}

enum TSQuantifier {
  TSQuantifierZero(0),
  TSQuantifierZeroOrOne(1),
  TSQuantifierZeroOrMore(2),
  TSQuantifierOne(3),
  TSQuantifierOneOrMore(4);

  final int value;
  const TSQuantifier(this.value);

  static TSQuantifier fromValue(int value) => switch (value) {
        0 => TSQuantifierZero,
        1 => TSQuantifierZeroOrOne,
        2 => TSQuantifierZeroOrMore,
        3 => TSQuantifierOne,
        4 => TSQuantifierOneOrMore,
        _ => throw ArgumentError('Unknown value for TSQuantifier: $value'),
      };
}

final class TSQueryMatch extends ffi.Struct {
  @ffi.Uint32()
  external int id;

  @ffi.Uint16()
  external int pattern_index;

  @ffi.Uint16()
  external int capture_count;

  external ffi.Pointer<TSQueryCapture> captures;
}

enum TSQueryPredicateStepType {
  TSQueryPredicateStepTypeDone(0),
  TSQueryPredicateStepTypeCapture(1),
  TSQueryPredicateStepTypeString(2);

  final int value;
  const TSQueryPredicateStepType(this.value);

  static TSQueryPredicateStepType fromValue(int value) => switch (value) {
        0 => TSQueryPredicateStepTypeDone,
        1 => TSQueryPredicateStepTypeCapture,
        2 => TSQueryPredicateStepTypeString,
        _ => throw ArgumentError(
            'Unknown value for TSQueryPredicateStepType: $value'),
      };
}

final class TSQueryPredicateStep extends ffi.Struct {
  @ffi.UnsignedInt()
  external int typeAsInt;

  TSQueryPredicateStepType get type =>
      TSQueryPredicateStepType.fromValue(typeAsInt);

  @ffi.Uint32()
  external int value_id;
}

enum TSQueryError {
  TSQueryErrorNone(0),
  TSQueryErrorSyntax(1),
  TSQueryErrorNodeType(2),
  TSQueryErrorField(3),
  TSQueryErrorCapture(4),
  TSQueryErrorStructure(5),
  TSQueryErrorLanguage(6);

  final int value;
  const TSQueryError(this.value);

  static TSQueryError fromValue(int value) => switch (value) {
        0 => TSQueryErrorNone,
        1 => TSQueryErrorSyntax,
        2 => TSQueryErrorNodeType,
        3 => TSQueryErrorField,
        4 => TSQueryErrorCapture,
        5 => TSQueryErrorStructure,
        6 => TSQueryErrorLanguage,
        _ => throw ArgumentError('Unknown value for TSQueryError: $value'),
      };
}

final class TSQueryCursorState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  @ffi.Uint32()
  external int current_byte_offset;
}

final class TSQueryCursorOptions extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<TSQueryCursorState> state)>>
      progress_callback;
}

/// The metadata associated with a language.
///
/// Currently, this metadata can be used to check the [Semantic Version](https://semver.org/)
/// of the language. This version information should be used to signal if a given parser might
/// be incompatible with existing queries when upgrading between major versions, or minor versions
/// if it's in zerover.
final class TSLanguageMetadata extends ffi.Struct {
  @ffi.Uint8()
  external int major_version;

  @ffi.Uint8()
  external int minor_version;

  @ffi.Uint8()
  external int patch_version;
}

final class wasm_engine_t extends ffi.Opaque {}

/// /
typedef TSWasmEngine = wasm_engine_t;

final class TSWasmStore extends ffi.Opaque {}

enum TSWasmErrorKind {
  TSWasmErrorKindNone(0),
  TSWasmErrorKindParse(1),
  TSWasmErrorKindCompile(2),
  TSWasmErrorKindInstantiate(3),
  TSWasmErrorKindAllocate(4);

  final int value;
  const TSWasmErrorKind(this.value);

  static TSWasmErrorKind fromValue(int value) => switch (value) {
        0 => TSWasmErrorKindNone,
        1 => TSWasmErrorKindParse,
        2 => TSWasmErrorKindCompile,
        3 => TSWasmErrorKindInstantiate,
        4 => TSWasmErrorKindAllocate,
        _ => throw ArgumentError('Unknown value for TSWasmErrorKind: $value'),
      };
}

final class TSWasmError extends ffi.Struct {
  @ffi.UnsignedInt()
  external int kindAsInt;

  TSWasmErrorKind get kind => TSWasmErrorKind.fromValue(kindAsInt);

  external ffi.Pointer<ffi.Char> message;
}

const int TREE_SITTER_LANGUAGE_VERSION = 15;

const int TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION = 13;
